// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v4.24.4
// source: alis/ideate/agent_card.proto

package ideate

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Declares a combination of a target URL, transport and protocol version for interacting with the agent.
// This allows agents to expose the same functionality over multiple protocol binding mechanisms.
type AgentInterface struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
	// Example: "https://api.example.com/a2a/v1", "https://grpc.example.com/a2a"
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// The protocol binding supported at this URL. This is an open form string, to be
	// easily extended for other protocol bindings. The core ones officially
	// supported are `JSONRPC`, `GRPC` and `HTTP+JSON`.
	ProtocolBinding string `protobuf:"bytes,2,opt,name=protocol_binding,json=protocolBinding,proto3" json:"protocol_binding,omitempty"`
	// Tenant to be set in the request when calling the agent.
	Tenant string `protobuf:"bytes,3,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// The version of the A2A protocol this interface exposes.
	// Use the latest supported minor version per major version.
	// Examples: "0.3", "1.0"
	ProtocolVersion string `protobuf:"bytes,4,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AgentInterface) Reset() {
	*x = AgentInterface{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentInterface) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentInterface) ProtoMessage() {}

func (x *AgentInterface) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentInterface.ProtoReflect.Descriptor instead.
func (*AgentInterface) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{0}
}

func (x *AgentInterface) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *AgentInterface) GetProtocolBinding() string {
	if x != nil {
		return x.ProtocolBinding
	}
	return ""
}

func (x *AgentInterface) GetTenant() string {
	if x != nil {
		return x.Tenant
	}
	return ""
}

func (x *AgentInterface) GetProtocolVersion() string {
	if x != nil {
		return x.ProtocolVersion
	}
	return ""
}

// A self-describing manifest for an agent. It provides essential
// metadata including the agent's identity, capabilities, skills, supported
// communication methods, and security requirements.
// Next ID: 20
type AgentCard struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A human readable name for the agent.
	// Example: "Recipe Agent"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// A human-readable description of the agent, assisting users and other agents
	// in understanding its purpose.
	// Example: "Agent that helps users with recipes and cooking."
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Ordered list of supported interfaces. First entry is preferred.
	SupportedInterfaces []*AgentInterface `protobuf:"bytes,19,rep,name=supported_interfaces,json=supportedInterfaces,proto3" json:"supported_interfaces,omitempty"`
	// The service provider of the agent.
	Provider *AgentProvider `protobuf:"bytes,4,opt,name=provider,proto3" json:"provider,omitempty"`
	// The version of the agent.
	// Example: "1.0.0"
	Version string `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
	// A url to provide additional documentation about the agent.
	DocumentationUrl *string `protobuf:"bytes,6,opt,name=documentation_url,json=documentationUrl,proto3,oneof" json:"documentation_url,omitempty"`
	// A2A Capability set supported by the agent.
	Capabilities *AgentCapabilities `protobuf:"bytes,7,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	// The security scheme details used for authenticating with this agent.
	SecuritySchemes map[string]*SecurityScheme `protobuf:"bytes,8,rep,name=security_schemes,json=securitySchemes,proto3" json:"security_schemes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Security requirements for contacting the agent.
	SecurityRequirements []*SecurityRequirement `protobuf:"bytes,13,rep,name=security_requirements,json=securityRequirements,proto3" json:"security_requirements,omitempty"`
	// protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
	// The set of interaction modes that the agent supports across all skills.
	// This can be overridden per skill. Defined as media types.
	DefaultInputModes []string `protobuf:"bytes,10,rep,name=default_input_modes,json=defaultInputModes,proto3" json:"default_input_modes,omitempty"`
	// The media types supported as outputs from this agent.
	DefaultOutputModes []string `protobuf:"bytes,11,rep,name=default_output_modes,json=defaultOutputModes,proto3" json:"default_output_modes,omitempty"`
	// Skills represent an ability of an agent. It is largely
	// a descriptive concept but represents a more focused set of behaviors that the
	// agent is likely to succeed at.
	Skills []*AgentSkill `protobuf:"bytes,12,rep,name=skills,proto3" json:"skills,omitempty"`
	// JSON Web Signatures computed for this AgentCard.
	Signatures []*AgentCardSignature `protobuf:"bytes,17,rep,name=signatures,proto3" json:"signatures,omitempty"`
	// An optional URL to an icon for the agent.
	IconUrl       *string `protobuf:"bytes,18,opt,name=icon_url,json=iconUrl,proto3,oneof" json:"icon_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentCard) Reset() {
	*x = AgentCard{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentCard) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentCard) ProtoMessage() {}

func (x *AgentCard) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentCard.ProtoReflect.Descriptor instead.
func (*AgentCard) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{1}
}

func (x *AgentCard) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AgentCard) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *AgentCard) GetSupportedInterfaces() []*AgentInterface {
	if x != nil {
		return x.SupportedInterfaces
	}
	return nil
}

func (x *AgentCard) GetProvider() *AgentProvider {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *AgentCard) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *AgentCard) GetDocumentationUrl() string {
	if x != nil && x.DocumentationUrl != nil {
		return *x.DocumentationUrl
	}
	return ""
}

func (x *AgentCard) GetCapabilities() *AgentCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *AgentCard) GetSecuritySchemes() map[string]*SecurityScheme {
	if x != nil {
		return x.SecuritySchemes
	}
	return nil
}

func (x *AgentCard) GetSecurityRequirements() []*SecurityRequirement {
	if x != nil {
		return x.SecurityRequirements
	}
	return nil
}

func (x *AgentCard) GetDefaultInputModes() []string {
	if x != nil {
		return x.DefaultInputModes
	}
	return nil
}

func (x *AgentCard) GetDefaultOutputModes() []string {
	if x != nil {
		return x.DefaultOutputModes
	}
	return nil
}

func (x *AgentCard) GetSkills() []*AgentSkill {
	if x != nil {
		return x.Skills
	}
	return nil
}

func (x *AgentCard) GetSignatures() []*AgentCardSignature {
	if x != nil {
		return x.Signatures
	}
	return nil
}

func (x *AgentCard) GetIconUrl() string {
	if x != nil && x.IconUrl != nil {
		return *x.IconUrl
	}
	return ""
}

// Represents the service provider of an agent.
type AgentProvider struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A URL for the agent provider's website or relevant documentation.
	// Example: "https://ai.google.dev"
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// The name of the agent provider's organization.
	// Example: "Google"
	Organization  string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentProvider) Reset() {
	*x = AgentProvider{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentProvider) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentProvider) ProtoMessage() {}

func (x *AgentProvider) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentProvider.ProtoReflect.Descriptor instead.
func (*AgentProvider) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{2}
}

func (x *AgentProvider) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *AgentProvider) GetOrganization() string {
	if x != nil {
		return x.Organization
	}
	return ""
}

// Defines optional capabilities supported by an agent.
type AgentCapabilities struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicates if the agent supports streaming responses.
	Streaming *bool `protobuf:"varint,1,opt,name=streaming,proto3,oneof" json:"streaming,omitempty"`
	// Indicates if the agent supports sending push notifications for asynchronous task updates.
	PushNotifications *bool `protobuf:"varint,2,opt,name=push_notifications,json=pushNotifications,proto3,oneof" json:"push_notifications,omitempty"`
	// A list of protocol extensions supported by the agent.
	Extensions []*AgentExtension `protobuf:"bytes,3,rep,name=extensions,proto3" json:"extensions,omitempty"`
	// Indicates if the agent supports providing an extended agent card when authenticated.
	ExtendedAgentCard *bool `protobuf:"varint,5,opt,name=extended_agent_card,json=extendedAgentCard,proto3,oneof" json:"extended_agent_card,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AgentCapabilities) Reset() {
	*x = AgentCapabilities{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentCapabilities) ProtoMessage() {}

func (x *AgentCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentCapabilities.ProtoReflect.Descriptor instead.
func (*AgentCapabilities) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{3}
}

func (x *AgentCapabilities) GetStreaming() bool {
	if x != nil && x.Streaming != nil {
		return *x.Streaming
	}
	return false
}

func (x *AgentCapabilities) GetPushNotifications() bool {
	if x != nil && x.PushNotifications != nil {
		return *x.PushNotifications
	}
	return false
}

func (x *AgentCapabilities) GetExtensions() []*AgentExtension {
	if x != nil {
		return x.Extensions
	}
	return nil
}

func (x *AgentCapabilities) GetExtendedAgentCard() bool {
	if x != nil && x.ExtendedAgentCard != nil {
		return *x.ExtendedAgentCard
	}
	return false
}

// A declaration of a protocol extension supported by an Agent.
type AgentExtension struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique URI identifying the extension.
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// A human-readable description of how this agent uses the extension.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// If true, the client must understand and comply with the extension's requirements.
	Required bool `protobuf:"varint,3,opt,name=required,proto3" json:"required,omitempty"`
	// Optional, extension-specific configuration parameters.
	Params        *structpb.Struct `protobuf:"bytes,4,opt,name=params,proto3" json:"params,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentExtension) Reset() {
	*x = AgentExtension{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentExtension) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentExtension) ProtoMessage() {}

func (x *AgentExtension) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentExtension.ProtoReflect.Descriptor instead.
func (*AgentExtension) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{4}
}

func (x *AgentExtension) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *AgentExtension) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *AgentExtension) GetRequired() bool {
	if x != nil {
		return x.Required
	}
	return false
}

func (x *AgentExtension) GetParams() *structpb.Struct {
	if x != nil {
		return x.Params
	}
	return nil
}

// Represents a distinct capability or function that an agent can perform.
type AgentSkill struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A unique identifier for the agent's skill.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// A human-readable name for the skill.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// A detailed description of the skill.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// A set of keywords describing the skill's capabilities.
	Tags []string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	// Example prompts or scenarios that this skill can handle.
	Examples []string `protobuf:"bytes,5,rep,name=examples,proto3" json:"examples,omitempty"`
	// The set of supported input media types for this skill, overriding the agent's defaults.
	InputModes []string `protobuf:"bytes,6,rep,name=input_modes,json=inputModes,proto3" json:"input_modes,omitempty"`
	// The set of supported output media types for this skill, overriding the agent's defaults.
	OutputModes []string `protobuf:"bytes,7,rep,name=output_modes,json=outputModes,proto3" json:"output_modes,omitempty"`
	// Security schemes necessary for this skill.
	SecurityRequirements []*SecurityRequirement `protobuf:"bytes,8,rep,name=security_requirements,json=securityRequirements,proto3" json:"security_requirements,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *AgentSkill) Reset() {
	*x = AgentSkill{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentSkill) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentSkill) ProtoMessage() {}

func (x *AgentSkill) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentSkill.ProtoReflect.Descriptor instead.
func (*AgentSkill) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{5}
}

func (x *AgentSkill) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AgentSkill) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AgentSkill) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *AgentSkill) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *AgentSkill) GetExamples() []string {
	if x != nil {
		return x.Examples
	}
	return nil
}

func (x *AgentSkill) GetInputModes() []string {
	if x != nil {
		return x.InputModes
	}
	return nil
}

func (x *AgentSkill) GetOutputModes() []string {
	if x != nil {
		return x.OutputModes
	}
	return nil
}

func (x *AgentSkill) GetSecurityRequirements() []*SecurityRequirement {
	if x != nil {
		return x.SecurityRequirements
	}
	return nil
}

// AgentCardSignature represents a JWS signature of an AgentCard.
// This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
type AgentCardSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The protected JWS header for the signature. This is always a
	// base64url-encoded JSON object. Required.
	Protected string `protobuf:"bytes,1,opt,name=protected,proto3" json:"protected,omitempty"`
	// The computed signature, base64url-encoded. Required.
	Signature string `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// The unprotected JWS header values.
	Header        *structpb.Struct `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentCardSignature) Reset() {
	*x = AgentCardSignature{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentCardSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentCardSignature) ProtoMessage() {}

func (x *AgentCardSignature) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentCardSignature.ProtoReflect.Descriptor instead.
func (*AgentCardSignature) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{6}
}

func (x *AgentCardSignature) GetProtected() string {
	if x != nil {
		return x.Protected
	}
	return ""
}

func (x *AgentCardSignature) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

func (x *AgentCardSignature) GetHeader() *structpb.Struct {
	if x != nil {
		return x.Header
	}
	return nil
}

// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
type StringList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	List          []string               `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StringList) Reset() {
	*x = StringList{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StringList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StringList) ProtoMessage() {}

func (x *StringList) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StringList.ProtoReflect.Descriptor instead.
func (*StringList) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{7}
}

func (x *StringList) GetList() []string {
	if x != nil {
		return x.List
	}
	return nil
}

type SecurityRequirement struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schemes       map[string]*StringList `protobuf:"bytes,1,rep,name=schemes,proto3" json:"schemes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecurityRequirement) Reset() {
	*x = SecurityRequirement{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecurityRequirement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityRequirement) ProtoMessage() {}

func (x *SecurityRequirement) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityRequirement.ProtoReflect.Descriptor instead.
func (*SecurityRequirement) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{8}
}

func (x *SecurityRequirement) GetSchemes() map[string]*StringList {
	if x != nil {
		return x.Schemes
	}
	return nil
}

// Defines a security scheme that can be used to secure an agent's endpoints.
// This is a discriminated union type based on the OpenAPI 3.2 Security Scheme Object.
// See: https://spec.openapis.org/oas/v3.2.0.html#security-scheme-object
type SecurityScheme struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Scheme:
	//
	//	*SecurityScheme_ApiKeySecurityScheme
	//	*SecurityScheme_HttpAuthSecurityScheme
	//	*SecurityScheme_Oauth2SecurityScheme
	//	*SecurityScheme_OpenIdConnectSecurityScheme
	//	*SecurityScheme_MtlsSecurityScheme
	Scheme        isSecurityScheme_Scheme `protobuf_oneof:"scheme"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecurityScheme) Reset() {
	*x = SecurityScheme{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecurityScheme) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityScheme) ProtoMessage() {}

func (x *SecurityScheme) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityScheme.ProtoReflect.Descriptor instead.
func (*SecurityScheme) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{9}
}

func (x *SecurityScheme) GetScheme() isSecurityScheme_Scheme {
	if x != nil {
		return x.Scheme
	}
	return nil
}

func (x *SecurityScheme) GetApiKeySecurityScheme() *APIKeySecurityScheme {
	if x != nil {
		if x, ok := x.Scheme.(*SecurityScheme_ApiKeySecurityScheme); ok {
			return x.ApiKeySecurityScheme
		}
	}
	return nil
}

func (x *SecurityScheme) GetHttpAuthSecurityScheme() *HTTPAuthSecurityScheme {
	if x != nil {
		if x, ok := x.Scheme.(*SecurityScheme_HttpAuthSecurityScheme); ok {
			return x.HttpAuthSecurityScheme
		}
	}
	return nil
}

func (x *SecurityScheme) GetOauth2SecurityScheme() *OAuth2SecurityScheme {
	if x != nil {
		if x, ok := x.Scheme.(*SecurityScheme_Oauth2SecurityScheme); ok {
			return x.Oauth2SecurityScheme
		}
	}
	return nil
}

func (x *SecurityScheme) GetOpenIdConnectSecurityScheme() *OpenIdConnectSecurityScheme {
	if x != nil {
		if x, ok := x.Scheme.(*SecurityScheme_OpenIdConnectSecurityScheme); ok {
			return x.OpenIdConnectSecurityScheme
		}
	}
	return nil
}

func (x *SecurityScheme) GetMtlsSecurityScheme() *MutualTlsSecurityScheme {
	if x != nil {
		if x, ok := x.Scheme.(*SecurityScheme_MtlsSecurityScheme); ok {
			return x.MtlsSecurityScheme
		}
	}
	return nil
}

type isSecurityScheme_Scheme interface {
	isSecurityScheme_Scheme()
}

type SecurityScheme_ApiKeySecurityScheme struct {
	// API key-based authentication.
	ApiKeySecurityScheme *APIKeySecurityScheme `protobuf:"bytes,1,opt,name=api_key_security_scheme,json=apiKeySecurityScheme,proto3,oneof"`
}

type SecurityScheme_HttpAuthSecurityScheme struct {
	// HTTP authentication (Basic, Bearer, etc.).
	HttpAuthSecurityScheme *HTTPAuthSecurityScheme `protobuf:"bytes,2,opt,name=http_auth_security_scheme,json=httpAuthSecurityScheme,proto3,oneof"`
}

type SecurityScheme_Oauth2SecurityScheme struct {
	// OAuth 2.0 authentication.
	Oauth2SecurityScheme *OAuth2SecurityScheme `protobuf:"bytes,3,opt,name=oauth2_security_scheme,json=oauth2SecurityScheme,proto3,oneof"`
}

type SecurityScheme_OpenIdConnectSecurityScheme struct {
	// OpenID Connect authentication.
	OpenIdConnectSecurityScheme *OpenIdConnectSecurityScheme `protobuf:"bytes,4,opt,name=open_id_connect_security_scheme,json=openIdConnectSecurityScheme,proto3,oneof"`
}

type SecurityScheme_MtlsSecurityScheme struct {
	// Mutual TLS authentication.
	MtlsSecurityScheme *MutualTlsSecurityScheme `protobuf:"bytes,5,opt,name=mtls_security_scheme,json=mtlsSecurityScheme,proto3,oneof"`
}

func (*SecurityScheme_ApiKeySecurityScheme) isSecurityScheme_Scheme() {}

func (*SecurityScheme_HttpAuthSecurityScheme) isSecurityScheme_Scheme() {}

func (*SecurityScheme_Oauth2SecurityScheme) isSecurityScheme_Scheme() {}

func (*SecurityScheme_OpenIdConnectSecurityScheme) isSecurityScheme_Scheme() {}

func (*SecurityScheme_MtlsSecurityScheme) isSecurityScheme_Scheme() {}

// Defines a security scheme using an API key.
type APIKeySecurityScheme struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional description for the security scheme.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// The location of the API key. Valid values are "query", "header", or "cookie".
	Location string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	// The name of the header, query, or cookie parameter to be used.
	Name          string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *APIKeySecurityScheme) Reset() {
	*x = APIKeySecurityScheme{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *APIKeySecurityScheme) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*APIKeySecurityScheme) ProtoMessage() {}

func (x *APIKeySecurityScheme) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use APIKeySecurityScheme.ProtoReflect.Descriptor instead.
func (*APIKeySecurityScheme) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{10}
}

func (x *APIKeySecurityScheme) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *APIKeySecurityScheme) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

func (x *APIKeySecurityScheme) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Defines a security scheme using HTTP authentication.
type HTTPAuthSecurityScheme struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional description for the security scheme.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// The name of the HTTP Authentication scheme to be used in the Authorization header,
	// as defined in RFC7235 (e.g., "Bearer").
	// This value should be registered in the IANA Authentication Scheme registry.
	Scheme string `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
	// A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
	// This is primarily for documentation purposes.
	BearerFormat  string `protobuf:"bytes,3,opt,name=bearer_format,json=bearerFormat,proto3" json:"bearer_format,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPAuthSecurityScheme) Reset() {
	*x = HTTPAuthSecurityScheme{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPAuthSecurityScheme) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPAuthSecurityScheme) ProtoMessage() {}

func (x *HTTPAuthSecurityScheme) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPAuthSecurityScheme.ProtoReflect.Descriptor instead.
func (*HTTPAuthSecurityScheme) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{11}
}

func (x *HTTPAuthSecurityScheme) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *HTTPAuthSecurityScheme) GetScheme() string {
	if x != nil {
		return x.Scheme
	}
	return ""
}

func (x *HTTPAuthSecurityScheme) GetBearerFormat() string {
	if x != nil {
		return x.BearerFormat
	}
	return ""
}

// Defines a security scheme using OAuth 2.0.
type OAuth2SecurityScheme struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional description for the security scheme.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// An object containing configuration information for the supported OAuth 2.0 flows.
	Flows *OAuthFlows `protobuf:"bytes,2,opt,name=flows,proto3" json:"flows,omitempty"`
	// URL to the oauth2 authorization server metadata
	// RFC8414 (https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
	Oauth2MetadataUrl string `protobuf:"bytes,3,opt,name=oauth2_metadata_url,json=oauth2MetadataUrl,proto3" json:"oauth2_metadata_url,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *OAuth2SecurityScheme) Reset() {
	*x = OAuth2SecurityScheme{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OAuth2SecurityScheme) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OAuth2SecurityScheme) ProtoMessage() {}

func (x *OAuth2SecurityScheme) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OAuth2SecurityScheme.ProtoReflect.Descriptor instead.
func (*OAuth2SecurityScheme) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{12}
}

func (x *OAuth2SecurityScheme) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *OAuth2SecurityScheme) GetFlows() *OAuthFlows {
	if x != nil {
		return x.Flows
	}
	return nil
}

func (x *OAuth2SecurityScheme) GetOauth2MetadataUrl() string {
	if x != nil {
		return x.Oauth2MetadataUrl
	}
	return ""
}

// Defines a security scheme using OpenID Connect.
type OpenIdConnectSecurityScheme struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional description for the security scheme.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// The OpenID Connect Discovery URL for the OIDC provider's metadata.
	// See: https://openid.net/specs/openid-connect-discovery-1_0.html
	OpenIdConnectUrl string `protobuf:"bytes,2,opt,name=open_id_connect_url,json=openIdConnectUrl,proto3" json:"open_id_connect_url,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *OpenIdConnectSecurityScheme) Reset() {
	*x = OpenIdConnectSecurityScheme{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OpenIdConnectSecurityScheme) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OpenIdConnectSecurityScheme) ProtoMessage() {}

func (x *OpenIdConnectSecurityScheme) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OpenIdConnectSecurityScheme.ProtoReflect.Descriptor instead.
func (*OpenIdConnectSecurityScheme) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{13}
}

func (x *OpenIdConnectSecurityScheme) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *OpenIdConnectSecurityScheme) GetOpenIdConnectUrl() string {
	if x != nil {
		return x.OpenIdConnectUrl
	}
	return ""
}

// Defines a security scheme using mTLS authentication.
type MutualTlsSecurityScheme struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional description for the security scheme.
	Description   string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MutualTlsSecurityScheme) Reset() {
	*x = MutualTlsSecurityScheme{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MutualTlsSecurityScheme) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MutualTlsSecurityScheme) ProtoMessage() {}

func (x *MutualTlsSecurityScheme) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MutualTlsSecurityScheme.ProtoReflect.Descriptor instead.
func (*MutualTlsSecurityScheme) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{14}
}

func (x *MutualTlsSecurityScheme) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

// Defines the configuration for the supported OAuth 2.0 flows.
type OAuthFlows struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Flow:
	//
	//	*OAuthFlows_AuthorizationCode
	//	*OAuthFlows_ClientCredentials
	//	*OAuthFlows_Implicit
	//	*OAuthFlows_Password
	//	*OAuthFlows_DeviceCode
	Flow          isOAuthFlows_Flow `protobuf_oneof:"flow"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OAuthFlows) Reset() {
	*x = OAuthFlows{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OAuthFlows) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OAuthFlows) ProtoMessage() {}

func (x *OAuthFlows) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OAuthFlows.ProtoReflect.Descriptor instead.
func (*OAuthFlows) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{15}
}

func (x *OAuthFlows) GetFlow() isOAuthFlows_Flow {
	if x != nil {
		return x.Flow
	}
	return nil
}

func (x *OAuthFlows) GetAuthorizationCode() *AuthorizationCodeOAuthFlow {
	if x != nil {
		if x, ok := x.Flow.(*OAuthFlows_AuthorizationCode); ok {
			return x.AuthorizationCode
		}
	}
	return nil
}

func (x *OAuthFlows) GetClientCredentials() *ClientCredentialsOAuthFlow {
	if x != nil {
		if x, ok := x.Flow.(*OAuthFlows_ClientCredentials); ok {
			return x.ClientCredentials
		}
	}
	return nil
}

// Deprecated: Marked as deprecated in alis/ideate/agent_card.proto.
func (x *OAuthFlows) GetImplicit() *ImplicitOAuthFlow {
	if x != nil {
		if x, ok := x.Flow.(*OAuthFlows_Implicit); ok {
			return x.Implicit
		}
	}
	return nil
}

// Deprecated: Marked as deprecated in alis/ideate/agent_card.proto.
func (x *OAuthFlows) GetPassword() *PasswordOAuthFlow {
	if x != nil {
		if x, ok := x.Flow.(*OAuthFlows_Password); ok {
			return x.Password
		}
	}
	return nil
}

func (x *OAuthFlows) GetDeviceCode() *DeviceCodeOAuthFlow {
	if x != nil {
		if x, ok := x.Flow.(*OAuthFlows_DeviceCode); ok {
			return x.DeviceCode
		}
	}
	return nil
}

type isOAuthFlows_Flow interface {
	isOAuthFlows_Flow()
}

type OAuthFlows_AuthorizationCode struct {
	// Configuration for the OAuth Authorization Code flow.
	AuthorizationCode *AuthorizationCodeOAuthFlow `protobuf:"bytes,1,opt,name=authorization_code,json=authorizationCode,proto3,oneof"`
}

type OAuthFlows_ClientCredentials struct {
	// Configuration for the OAuth Client Credentials flow.
	ClientCredentials *ClientCredentialsOAuthFlow `protobuf:"bytes,2,opt,name=client_credentials,json=clientCredentials,proto3,oneof"`
}

type OAuthFlows_Implicit struct {
	// Deprecated: Marked as deprecated in alis/ideate/agent_card.proto.
	Implicit *ImplicitOAuthFlow `protobuf:"bytes,3,opt,name=implicit,proto3,oneof"`
}

type OAuthFlows_Password struct {
	// Deprecated: Marked as deprecated in alis/ideate/agent_card.proto.
	Password *PasswordOAuthFlow `protobuf:"bytes,4,opt,name=password,proto3,oneof"`
}

type OAuthFlows_DeviceCode struct {
	// Configuration for the OAuth Device Code flow.
	DeviceCode *DeviceCodeOAuthFlow `protobuf:"bytes,5,opt,name=device_code,json=deviceCode,proto3,oneof"`
}

func (*OAuthFlows_AuthorizationCode) isOAuthFlows_Flow() {}

func (*OAuthFlows_ClientCredentials) isOAuthFlows_Flow() {}

func (*OAuthFlows_Implicit) isOAuthFlows_Flow() {}

func (*OAuthFlows_Password) isOAuthFlows_Flow() {}

func (*OAuthFlows_DeviceCode) isOAuthFlows_Flow() {}

// Defines configuration details for the OAuth 2.0 Authorization Code flow.
type AuthorizationCodeOAuthFlow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The authorization URL to be used for this flow.
	AuthorizationUrl string `protobuf:"bytes,1,opt,name=authorization_url,json=authorizationUrl,proto3" json:"authorization_url,omitempty"`
	// The token URL to be used for this flow.
	TokenUrl string `protobuf:"bytes,2,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
	// The URL to be used for obtaining refresh tokens.
	RefreshUrl string `protobuf:"bytes,3,opt,name=refresh_url,json=refreshUrl,proto3" json:"refresh_url,omitempty"`
	// The available scopes for the OAuth2 security scheme.
	Scopes map[string]string `protobuf:"bytes,4,rep,name=scopes,proto3" json:"scopes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Indicates if PKCE (RFC 7636) is required for this flow.
	// PKCE should always be used for public clients and is recommended for all clients.
	PkceRequired  bool `protobuf:"varint,5,opt,name=pkce_required,json=pkceRequired,proto3" json:"pkce_required,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthorizationCodeOAuthFlow) Reset() {
	*x = AuthorizationCodeOAuthFlow{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthorizationCodeOAuthFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthorizationCodeOAuthFlow) ProtoMessage() {}

func (x *AuthorizationCodeOAuthFlow) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthorizationCodeOAuthFlow.ProtoReflect.Descriptor instead.
func (*AuthorizationCodeOAuthFlow) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{16}
}

func (x *AuthorizationCodeOAuthFlow) GetAuthorizationUrl() string {
	if x != nil {
		return x.AuthorizationUrl
	}
	return ""
}

func (x *AuthorizationCodeOAuthFlow) GetTokenUrl() string {
	if x != nil {
		return x.TokenUrl
	}
	return ""
}

func (x *AuthorizationCodeOAuthFlow) GetRefreshUrl() string {
	if x != nil {
		return x.RefreshUrl
	}
	return ""
}

func (x *AuthorizationCodeOAuthFlow) GetScopes() map[string]string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

func (x *AuthorizationCodeOAuthFlow) GetPkceRequired() bool {
	if x != nil {
		return x.PkceRequired
	}
	return false
}

// Defines configuration details for the OAuth 2.0 Client Credentials flow.
type ClientCredentialsOAuthFlow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The token URL to be used for this flow.
	TokenUrl string `protobuf:"bytes,1,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
	// The URL to be used for obtaining refresh tokens.
	RefreshUrl string `protobuf:"bytes,2,opt,name=refresh_url,json=refreshUrl,proto3" json:"refresh_url,omitempty"`
	// The available scopes for the OAuth2 security scheme.
	Scopes        map[string]string `protobuf:"bytes,3,rep,name=scopes,proto3" json:"scopes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientCredentialsOAuthFlow) Reset() {
	*x = ClientCredentialsOAuthFlow{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientCredentialsOAuthFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientCredentialsOAuthFlow) ProtoMessage() {}

func (x *ClientCredentialsOAuthFlow) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientCredentialsOAuthFlow.ProtoReflect.Descriptor instead.
func (*ClientCredentialsOAuthFlow) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{17}
}

func (x *ClientCredentialsOAuthFlow) GetTokenUrl() string {
	if x != nil {
		return x.TokenUrl
	}
	return ""
}

func (x *ClientCredentialsOAuthFlow) GetRefreshUrl() string {
	if x != nil {
		return x.RefreshUrl
	}
	return ""
}

func (x *ClientCredentialsOAuthFlow) GetScopes() map[string]string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

// DEPRECATED
type ImplicitOAuthFlow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The authorization URL to be used for this flow. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS
	AuthorizationUrl string `protobuf:"bytes,1,opt,name=authorization_url,json=authorizationUrl,proto3" json:"authorization_url,omitempty"`
	// The URL to be used for obtaining refresh tokens. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS.
	RefreshUrl string `protobuf:"bytes,2,opt,name=refresh_url,json=refreshUrl,proto3" json:"refresh_url,omitempty"`
	// The available scopes for the OAuth2 security scheme. A map between the
	// scope name and a short description for it. The map MAY be empty.
	Scopes        map[string]string `protobuf:"bytes,3,rep,name=scopes,proto3" json:"scopes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImplicitOAuthFlow) Reset() {
	*x = ImplicitOAuthFlow{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImplicitOAuthFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImplicitOAuthFlow) ProtoMessage() {}

func (x *ImplicitOAuthFlow) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImplicitOAuthFlow.ProtoReflect.Descriptor instead.
func (*ImplicitOAuthFlow) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{18}
}

func (x *ImplicitOAuthFlow) GetAuthorizationUrl() string {
	if x != nil {
		return x.AuthorizationUrl
	}
	return ""
}

func (x *ImplicitOAuthFlow) GetRefreshUrl() string {
	if x != nil {
		return x.RefreshUrl
	}
	return ""
}

func (x *ImplicitOAuthFlow) GetScopes() map[string]string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

// DEPRECATED
type PasswordOAuthFlow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The token URL to be used for this flow. This MUST be in the form of a URL.
	// The OAuth2 standard requires the use of TLS.
	TokenUrl string `protobuf:"bytes,1,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
	// The URL to be used for obtaining refresh tokens. This MUST be in the
	// form of a URL. The OAuth2 standard requires the use of TLS.
	RefreshUrl string `protobuf:"bytes,2,opt,name=refresh_url,json=refreshUrl,proto3" json:"refresh_url,omitempty"`
	// The available scopes for the OAuth2 security scheme. A map between the
	// scope name and a short description for it. The map MAY be empty.
	Scopes        map[string]string `protobuf:"bytes,3,rep,name=scopes,proto3" json:"scopes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PasswordOAuthFlow) Reset() {
	*x = PasswordOAuthFlow{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PasswordOAuthFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PasswordOAuthFlow) ProtoMessage() {}

func (x *PasswordOAuthFlow) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PasswordOAuthFlow.ProtoReflect.Descriptor instead.
func (*PasswordOAuthFlow) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{19}
}

func (x *PasswordOAuthFlow) GetTokenUrl() string {
	if x != nil {
		return x.TokenUrl
	}
	return ""
}

func (x *PasswordOAuthFlow) GetRefreshUrl() string {
	if x != nil {
		return x.RefreshUrl
	}
	return ""
}

func (x *PasswordOAuthFlow) GetScopes() map[string]string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

// Defines configuration details for the OAuth 2.0 Device Code flow (RFC 8628).
// This flow is designed for input-constrained devices such as IoT devices,
// and CLI tools where the user authenticates on a separate device.
type DeviceCodeOAuthFlow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The device authorization endpoint URL.
	DeviceAuthorizationUrl string `protobuf:"bytes,1,opt,name=device_authorization_url,json=deviceAuthorizationUrl,proto3" json:"device_authorization_url,omitempty"`
	// The token URL to be used for this flow.
	TokenUrl string `protobuf:"bytes,2,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
	// The URL to be used for obtaining refresh tokens.
	RefreshUrl string `protobuf:"bytes,3,opt,name=refresh_url,json=refreshUrl,proto3" json:"refresh_url,omitempty"`
	// The available scopes for the OAuth2 security scheme.
	Scopes        map[string]string `protobuf:"bytes,4,rep,name=scopes,proto3" json:"scopes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeviceCodeOAuthFlow) Reset() {
	*x = DeviceCodeOAuthFlow{}
	mi := &file_alis_ideate_agent_card_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeviceCodeOAuthFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeviceCodeOAuthFlow) ProtoMessage() {}

func (x *DeviceCodeOAuthFlow) ProtoReflect() protoreflect.Message {
	mi := &file_alis_ideate_agent_card_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeviceCodeOAuthFlow.ProtoReflect.Descriptor instead.
func (*DeviceCodeOAuthFlow) Descriptor() ([]byte, []int) {
	return file_alis_ideate_agent_card_proto_rawDescGZIP(), []int{20}
}

func (x *DeviceCodeOAuthFlow) GetDeviceAuthorizationUrl() string {
	if x != nil {
		return x.DeviceAuthorizationUrl
	}
	return ""
}

func (x *DeviceCodeOAuthFlow) GetTokenUrl() string {
	if x != nil {
		return x.TokenUrl
	}
	return ""
}

func (x *DeviceCodeOAuthFlow) GetRefreshUrl() string {
	if x != nil {
		return x.RefreshUrl
	}
	return ""
}

func (x *DeviceCodeOAuthFlow) GetScopes() map[string]string {
	if x != nil {
		return x.Scopes
	}
	return nil
}

var File_alis_ideate_agent_card_proto protoreflect.FileDescriptor

const file_alis_ideate_agent_card_proto_rawDesc = "" +
	"\n" +
	"\x1calis/ideate/agent_card.proto\x12\valis.ideate\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xa2\x01\n" +
	"\x0eAgentInterface\x12\x16\n" +
	"\x03url\x18\x01 \x01(\tB\x04\xe2A\x01\x02R\x03url\x12/\n" +
	"\x10protocol_binding\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\x0fprotocolBinding\x12\x16\n" +
	"\x06tenant\x18\x03 \x01(\tR\x06tenant\x12/\n" +
	"\x10protocol_version\x18\x04 \x01(\tB\x04\xe2A\x01\x02R\x0fprotocolVersion\"\xce\a\n" +
	"\tAgentCard\x12\x18\n" +
	"\x04name\x18\x01 \x01(\tB\x04\xe2A\x01\x02R\x04name\x12&\n" +
	"\vdescription\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\vdescription\x12T\n" +
	"\x14supported_interfaces\x18\x13 \x03(\v2\x1b.alis.ideate.AgentInterfaceB\x04\xe2A\x01\x02R\x13supportedInterfaces\x126\n" +
	"\bprovider\x18\x04 \x01(\v2\x1a.alis.ideate.AgentProviderR\bprovider\x12\x1e\n" +
	"\aversion\x18\x05 \x01(\tB\x04\xe2A\x01\x02R\aversion\x120\n" +
	"\x11documentation_url\x18\x06 \x01(\tH\x00R\x10documentationUrl\x88\x01\x01\x12H\n" +
	"\fcapabilities\x18\a \x01(\v2\x1e.alis.ideate.AgentCapabilitiesB\x04\xe2A\x01\x02R\fcapabilities\x12V\n" +
	"\x10security_schemes\x18\b \x03(\v2+.alis.ideate.AgentCard.SecuritySchemesEntryR\x0fsecuritySchemes\x12U\n" +
	"\x15security_requirements\x18\r \x03(\v2 .alis.ideate.SecurityRequirementR\x14securityRequirements\x124\n" +
	"\x13default_input_modes\x18\n" +
	" \x03(\tB\x04\xe2A\x01\x02R\x11defaultInputModes\x126\n" +
	"\x14default_output_modes\x18\v \x03(\tB\x04\xe2A\x01\x02R\x12defaultOutputModes\x125\n" +
	"\x06skills\x18\f \x03(\v2\x17.alis.ideate.AgentSkillB\x04\xe2A\x01\x02R\x06skills\x12?\n" +
	"\n" +
	"signatures\x18\x11 \x03(\v2\x1f.alis.ideate.AgentCardSignatureR\n" +
	"signatures\x12\x1e\n" +
	"\bicon_url\x18\x12 \x01(\tH\x01R\aiconUrl\x88\x01\x01\x1a_\n" +
	"\x14SecuritySchemesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x121\n" +
	"\x05value\x18\x02 \x01(\v2\x1b.alis.ideate.SecuritySchemeR\x05value:\x028\x01B\x14\n" +
	"\x12_documentation_urlB\v\n" +
	"\t_icon_urlJ\x04\b\x03\x10\x04J\x04\b\t\x10\n" +
	"J\x04\b\x0e\x10\x0fJ\x04\b\x0f\x10\x10J\x04\b\x10\x10\x11\"Q\n" +
	"\rAgentProvider\x12\x16\n" +
	"\x03url\x18\x01 \x01(\tB\x04\xe2A\x01\x02R\x03url\x12(\n" +
	"\forganization\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\forganization\"\x9f\x02\n" +
	"\x11AgentCapabilities\x12!\n" +
	"\tstreaming\x18\x01 \x01(\bH\x00R\tstreaming\x88\x01\x01\x122\n" +
	"\x12push_notifications\x18\x02 \x01(\bH\x01R\x11pushNotifications\x88\x01\x01\x12;\n" +
	"\n" +
	"extensions\x18\x03 \x03(\v2\x1b.alis.ideate.AgentExtensionR\n" +
	"extensions\x123\n" +
	"\x13extended_agent_card\x18\x05 \x01(\bH\x02R\x11extendedAgentCard\x88\x01\x01B\f\n" +
	"\n" +
	"_streamingB\x15\n" +
	"\x13_push_notificationsB\x16\n" +
	"\x14_extended_agent_cardJ\x04\b\x04\x10\x05\"\x91\x01\n" +
	"\x0eAgentExtension\x12\x10\n" +
	"\x03uri\x18\x01 \x01(\tR\x03uri\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x1a\n" +
	"\brequired\x18\x03 \x01(\bR\brequired\x12/\n" +
	"\x06params\x18\x04 \x01(\v2\x17.google.protobuf.StructR\x06params\"\xb5\x02\n" +
	"\n" +
	"AgentSkill\x12\x14\n" +
	"\x02id\x18\x01 \x01(\tB\x04\xe2A\x01\x02R\x02id\x12\x18\n" +
	"\x04name\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\x04name\x12&\n" +
	"\vdescription\x18\x03 \x01(\tB\x04\xe2A\x01\x02R\vdescription\x12\x18\n" +
	"\x04tags\x18\x04 \x03(\tB\x04\xe2A\x01\x02R\x04tags\x12\x1a\n" +
	"\bexamples\x18\x05 \x03(\tR\bexamples\x12\x1f\n" +
	"\vinput_modes\x18\x06 \x03(\tR\n" +
	"inputModes\x12!\n" +
	"\foutput_modes\x18\a \x03(\tR\voutputModes\x12U\n" +
	"\x15security_requirements\x18\b \x03(\v2 .alis.ideate.SecurityRequirementR\x14securityRequirements\"\x8d\x01\n" +
	"\x12AgentCardSignature\x12\"\n" +
	"\tprotected\x18\x01 \x01(\tB\x04\xe2A\x01\x02R\tprotected\x12\"\n" +
	"\tsignature\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\tsignature\x12/\n" +
	"\x06header\x18\x03 \x01(\v2\x17.google.protobuf.StructR\x06header\" \n" +
	"\n" +
	"StringList\x12\x12\n" +
	"\x04list\x18\x01 \x03(\tR\x04list\"\xb3\x01\n" +
	"\x13SecurityRequirement\x12G\n" +
	"\aschemes\x18\x01 \x03(\v2-.alis.ideate.SecurityRequirement.SchemesEntryR\aschemes\x1aS\n" +
	"\fSchemesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12-\n" +
	"\x05value\x18\x02 \x01(\v2\x17.alis.ideate.StringListR\x05value:\x028\x01\"\xff\x03\n" +
	"\x0eSecurityScheme\x12Z\n" +
	"\x17api_key_security_scheme\x18\x01 \x01(\v2!.alis.ideate.APIKeySecuritySchemeH\x00R\x14apiKeySecurityScheme\x12`\n" +
	"\x19http_auth_security_scheme\x18\x02 \x01(\v2#.alis.ideate.HTTPAuthSecuritySchemeH\x00R\x16httpAuthSecurityScheme\x12Y\n" +
	"\x16oauth2_security_scheme\x18\x03 \x01(\v2!.alis.ideate.OAuth2SecuritySchemeH\x00R\x14oauth2SecurityScheme\x12p\n" +
	"\x1fopen_id_connect_security_scheme\x18\x04 \x01(\v2(.alis.ideate.OpenIdConnectSecuritySchemeH\x00R\x1bopenIdConnectSecurityScheme\x12X\n" +
	"\x14mtls_security_scheme\x18\x05 \x01(\v2$.alis.ideate.MutualTlsSecuritySchemeH\x00R\x12mtlsSecuritySchemeB\b\n" +
	"\x06scheme\"t\n" +
	"\x14APIKeySecurityScheme\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x12 \n" +
	"\blocation\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\blocation\x12\x18\n" +
	"\x04name\x18\x03 \x01(\tB\x04\xe2A\x01\x02R\x04name\"}\n" +
	"\x16HTTPAuthSecurityScheme\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x12\x1c\n" +
	"\x06scheme\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\x06scheme\x12#\n" +
	"\rbearer_format\x18\x03 \x01(\tR\fbearerFormat\"\x9d\x01\n" +
	"\x14OAuth2SecurityScheme\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x123\n" +
	"\x05flows\x18\x02 \x01(\v2\x17.alis.ideate.OAuthFlowsB\x04\xe2A\x01\x02R\x05flows\x12.\n" +
	"\x13oauth2_metadata_url\x18\x03 \x01(\tR\x11oauth2MetadataUrl\"t\n" +
	"\x1bOpenIdConnectSecurityScheme\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x123\n" +
	"\x13open_id_connect_url\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\x10openIdConnectUrl\";\n" +
	"\x17MutualTlsSecurityScheme\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\"\x91\x03\n" +
	"\n" +
	"OAuthFlows\x12X\n" +
	"\x12authorization_code\x18\x01 \x01(\v2'.alis.ideate.AuthorizationCodeOAuthFlowH\x00R\x11authorizationCode\x12X\n" +
	"\x12client_credentials\x18\x02 \x01(\v2'.alis.ideate.ClientCredentialsOAuthFlowH\x00R\x11clientCredentials\x12@\n" +
	"\bimplicit\x18\x03 \x01(\v2\x1e.alis.ideate.ImplicitOAuthFlowB\x02\x18\x01H\x00R\bimplicit\x12@\n" +
	"\bpassword\x18\x04 \x01(\v2\x1e.alis.ideate.PasswordOAuthFlowB\x02\x18\x01H\x00R\bpassword\x12C\n" +
	"\vdevice_code\x18\x05 \x01(\v2 .alis.ideate.DeviceCodeOAuthFlowH\x00R\n" +
	"deviceCodeB\x06\n" +
	"\x04flow\"\xc6\x02\n" +
	"\x1aAuthorizationCodeOAuthFlow\x121\n" +
	"\x11authorization_url\x18\x01 \x01(\tB\x04\xe2A\x01\x02R\x10authorizationUrl\x12!\n" +
	"\ttoken_url\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\btokenUrl\x12\x1f\n" +
	"\vrefresh_url\x18\x03 \x01(\tR\n" +
	"refreshUrl\x12Q\n" +
	"\x06scopes\x18\x04 \x03(\v23.alis.ideate.AuthorizationCodeOAuthFlow.ScopesEntryB\x04\xe2A\x01\x02R\x06scopes\x12#\n" +
	"\rpkce_required\x18\x05 \x01(\bR\fpkceRequired\x1a9\n" +
	"\vScopesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xee\x01\n" +
	"\x1aClientCredentialsOAuthFlow\x12!\n" +
	"\ttoken_url\x18\x01 \x01(\tB\x04\xe2A\x01\x02R\btokenUrl\x12\x1f\n" +
	"\vrefresh_url\x18\x02 \x01(\tR\n" +
	"refreshUrl\x12Q\n" +
	"\x06scopes\x18\x03 \x03(\v23.alis.ideate.ClientCredentialsOAuthFlow.ScopesEntryB\x04\xe2A\x01\x02R\x06scopes\x1a9\n" +
	"\vScopesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe0\x01\n" +
	"\x11ImplicitOAuthFlow\x12+\n" +
	"\x11authorization_url\x18\x01 \x01(\tR\x10authorizationUrl\x12\x1f\n" +
	"\vrefresh_url\x18\x02 \x01(\tR\n" +
	"refreshUrl\x12B\n" +
	"\x06scopes\x18\x03 \x03(\v2*.alis.ideate.ImplicitOAuthFlow.ScopesEntryR\x06scopes\x1a9\n" +
	"\vScopesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xd0\x01\n" +
	"\x11PasswordOAuthFlow\x12\x1b\n" +
	"\ttoken_url\x18\x01 \x01(\tR\btokenUrl\x12\x1f\n" +
	"\vrefresh_url\x18\x02 \x01(\tR\n" +
	"refreshUrl\x12B\n" +
	"\x06scopes\x18\x03 \x03(\v2*.alis.ideate.PasswordOAuthFlow.ScopesEntryR\x06scopes\x1a9\n" +
	"\vScopesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa0\x02\n" +
	"\x13DeviceCodeOAuthFlow\x12>\n" +
	"\x18device_authorization_url\x18\x01 \x01(\tB\x04\xe2A\x01\x02R\x16deviceAuthorizationUrl\x12!\n" +
	"\ttoken_url\x18\x02 \x01(\tB\x04\xe2A\x01\x02R\btokenUrl\x12\x1f\n" +
	"\vrefresh_url\x18\x03 \x01(\tR\n" +
	"refreshUrl\x12J\n" +
	"\x06scopes\x18\x04 \x03(\v2,.alis.ideate.DeviceCodeOAuthFlow.ScopesEntryB\x04\xe2A\x01\x02R\x06scopes\x1a9\n" +
	"\vScopesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B0Z.github.com/alis-exchange/ideate-go/alis/ideateb\x06proto3"

var (
	file_alis_ideate_agent_card_proto_rawDescOnce sync.Once
	file_alis_ideate_agent_card_proto_rawDescData []byte
)

func file_alis_ideate_agent_card_proto_rawDescGZIP() []byte {
	file_alis_ideate_agent_card_proto_rawDescOnce.Do(func() {
		file_alis_ideate_agent_card_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_alis_ideate_agent_card_proto_rawDesc), len(file_alis_ideate_agent_card_proto_rawDesc)))
	})
	return file_alis_ideate_agent_card_proto_rawDescData
}

var file_alis_ideate_agent_card_proto_msgTypes = make([]protoimpl.MessageInfo, 28)
var file_alis_ideate_agent_card_proto_goTypes = []any{
	(*AgentInterface)(nil),              // 0: alis.ideate.AgentInterface
	(*AgentCard)(nil),                   // 1: alis.ideate.AgentCard
	(*AgentProvider)(nil),               // 2: alis.ideate.AgentProvider
	(*AgentCapabilities)(nil),           // 3: alis.ideate.AgentCapabilities
	(*AgentExtension)(nil),              // 4: alis.ideate.AgentExtension
	(*AgentSkill)(nil),                  // 5: alis.ideate.AgentSkill
	(*AgentCardSignature)(nil),          // 6: alis.ideate.AgentCardSignature
	(*StringList)(nil),                  // 7: alis.ideate.StringList
	(*SecurityRequirement)(nil),         // 8: alis.ideate.SecurityRequirement
	(*SecurityScheme)(nil),              // 9: alis.ideate.SecurityScheme
	(*APIKeySecurityScheme)(nil),        // 10: alis.ideate.APIKeySecurityScheme
	(*HTTPAuthSecurityScheme)(nil),      // 11: alis.ideate.HTTPAuthSecurityScheme
	(*OAuth2SecurityScheme)(nil),        // 12: alis.ideate.OAuth2SecurityScheme
	(*OpenIdConnectSecurityScheme)(nil), // 13: alis.ideate.OpenIdConnectSecurityScheme
	(*MutualTlsSecurityScheme)(nil),     // 14: alis.ideate.MutualTlsSecurityScheme
	(*OAuthFlows)(nil),                  // 15: alis.ideate.OAuthFlows
	(*AuthorizationCodeOAuthFlow)(nil),  // 16: alis.ideate.AuthorizationCodeOAuthFlow
	(*ClientCredentialsOAuthFlow)(nil),  // 17: alis.ideate.ClientCredentialsOAuthFlow
	(*ImplicitOAuthFlow)(nil),           // 18: alis.ideate.ImplicitOAuthFlow
	(*PasswordOAuthFlow)(nil),           // 19: alis.ideate.PasswordOAuthFlow
	(*DeviceCodeOAuthFlow)(nil),         // 20: alis.ideate.DeviceCodeOAuthFlow
	nil,                                 // 21: alis.ideate.AgentCard.SecuritySchemesEntry
	nil,                                 // 22: alis.ideate.SecurityRequirement.SchemesEntry
	nil,                                 // 23: alis.ideate.AuthorizationCodeOAuthFlow.ScopesEntry
	nil,                                 // 24: alis.ideate.ClientCredentialsOAuthFlow.ScopesEntry
	nil,                                 // 25: alis.ideate.ImplicitOAuthFlow.ScopesEntry
	nil,                                 // 26: alis.ideate.PasswordOAuthFlow.ScopesEntry
	nil,                                 // 27: alis.ideate.DeviceCodeOAuthFlow.ScopesEntry
	(*structpb.Struct)(nil),             // 28: google.protobuf.Struct
}
var file_alis_ideate_agent_card_proto_depIdxs = []int32{
	0,  // 0: alis.ideate.AgentCard.supported_interfaces:type_name -> alis.ideate.AgentInterface
	2,  // 1: alis.ideate.AgentCard.provider:type_name -> alis.ideate.AgentProvider
	3,  // 2: alis.ideate.AgentCard.capabilities:type_name -> alis.ideate.AgentCapabilities
	21, // 3: alis.ideate.AgentCard.security_schemes:type_name -> alis.ideate.AgentCard.SecuritySchemesEntry
	8,  // 4: alis.ideate.AgentCard.security_requirements:type_name -> alis.ideate.SecurityRequirement
	5,  // 5: alis.ideate.AgentCard.skills:type_name -> alis.ideate.AgentSkill
	6,  // 6: alis.ideate.AgentCard.signatures:type_name -> alis.ideate.AgentCardSignature
	4,  // 7: alis.ideate.AgentCapabilities.extensions:type_name -> alis.ideate.AgentExtension
	28, // 8: alis.ideate.AgentExtension.params:type_name -> google.protobuf.Struct
	8,  // 9: alis.ideate.AgentSkill.security_requirements:type_name -> alis.ideate.SecurityRequirement
	28, // 10: alis.ideate.AgentCardSignature.header:type_name -> google.protobuf.Struct
	22, // 11: alis.ideate.SecurityRequirement.schemes:type_name -> alis.ideate.SecurityRequirement.SchemesEntry
	10, // 12: alis.ideate.SecurityScheme.api_key_security_scheme:type_name -> alis.ideate.APIKeySecurityScheme
	11, // 13: alis.ideate.SecurityScheme.http_auth_security_scheme:type_name -> alis.ideate.HTTPAuthSecurityScheme
	12, // 14: alis.ideate.SecurityScheme.oauth2_security_scheme:type_name -> alis.ideate.OAuth2SecurityScheme
	13, // 15: alis.ideate.SecurityScheme.open_id_connect_security_scheme:type_name -> alis.ideate.OpenIdConnectSecurityScheme
	14, // 16: alis.ideate.SecurityScheme.mtls_security_scheme:type_name -> alis.ideate.MutualTlsSecurityScheme
	15, // 17: alis.ideate.OAuth2SecurityScheme.flows:type_name -> alis.ideate.OAuthFlows
	16, // 18: alis.ideate.OAuthFlows.authorization_code:type_name -> alis.ideate.AuthorizationCodeOAuthFlow
	17, // 19: alis.ideate.OAuthFlows.client_credentials:type_name -> alis.ideate.ClientCredentialsOAuthFlow
	18, // 20: alis.ideate.OAuthFlows.implicit:type_name -> alis.ideate.ImplicitOAuthFlow
	19, // 21: alis.ideate.OAuthFlows.password:type_name -> alis.ideate.PasswordOAuthFlow
	20, // 22: alis.ideate.OAuthFlows.device_code:type_name -> alis.ideate.DeviceCodeOAuthFlow
	23, // 23: alis.ideate.AuthorizationCodeOAuthFlow.scopes:type_name -> alis.ideate.AuthorizationCodeOAuthFlow.ScopesEntry
	24, // 24: alis.ideate.ClientCredentialsOAuthFlow.scopes:type_name -> alis.ideate.ClientCredentialsOAuthFlow.ScopesEntry
	25, // 25: alis.ideate.ImplicitOAuthFlow.scopes:type_name -> alis.ideate.ImplicitOAuthFlow.ScopesEntry
	26, // 26: alis.ideate.PasswordOAuthFlow.scopes:type_name -> alis.ideate.PasswordOAuthFlow.ScopesEntry
	27, // 27: alis.ideate.DeviceCodeOAuthFlow.scopes:type_name -> alis.ideate.DeviceCodeOAuthFlow.ScopesEntry
	9,  // 28: alis.ideate.AgentCard.SecuritySchemesEntry.value:type_name -> alis.ideate.SecurityScheme
	7,  // 29: alis.ideate.SecurityRequirement.SchemesEntry.value:type_name -> alis.ideate.StringList
	30, // [30:30] is the sub-list for method output_type
	30, // [30:30] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_alis_ideate_agent_card_proto_init() }
func file_alis_ideate_agent_card_proto_init() {
	if File_alis_ideate_agent_card_proto != nil {
		return
	}
	file_alis_ideate_agent_card_proto_msgTypes[1].OneofWrappers = []any{}
	file_alis_ideate_agent_card_proto_msgTypes[3].OneofWrappers = []any{}
	file_alis_ideate_agent_card_proto_msgTypes[9].OneofWrappers = []any{
		(*SecurityScheme_ApiKeySecurityScheme)(nil),
		(*SecurityScheme_HttpAuthSecurityScheme)(nil),
		(*SecurityScheme_Oauth2SecurityScheme)(nil),
		(*SecurityScheme_OpenIdConnectSecurityScheme)(nil),
		(*SecurityScheme_MtlsSecurityScheme)(nil),
	}
	file_alis_ideate_agent_card_proto_msgTypes[15].OneofWrappers = []any{
		(*OAuthFlows_AuthorizationCode)(nil),
		(*OAuthFlows_ClientCredentials)(nil),
		(*OAuthFlows_Implicit)(nil),
		(*OAuthFlows_Password)(nil),
		(*OAuthFlows_DeviceCode)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_alis_ideate_agent_card_proto_rawDesc), len(file_alis_ideate_agent_card_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   28,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_alis_ideate_agent_card_proto_goTypes,
		DependencyIndexes: file_alis_ideate_agent_card_proto_depIdxs,
		MessageInfos:      file_alis_ideate_agent_card_proto_msgTypes,
	}.Build()
	File_alis_ideate_agent_card_proto = out.File
	file_alis_ideate_agent_card_proto_goTypes = nil
	file_alis_ideate_agent_card_proto_depIdxs = nil
}
